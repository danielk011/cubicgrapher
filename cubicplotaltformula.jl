using HomotopyContinuation
using Pkg
import Base.isequal
import Base.==
import Base.unique
@var a b c d t x1 y1 x2 y2
struct Line
    lineequations::Vector
end

function ==(x::Line,y::Line)
    compareAdjustedLines(x.lineequations,y.lineequations)#isequal(x,y)
end
function makeunique(rawLineArray)
    lineArray=map(x -> Line(x),rawLineArray)
    return map(x -> x.lineequations,unique(lineArray))
end

plane1=(1,0,0)
plane2=(0,1,0)
plane3=(0,0,1)
X2=(1,0,0)
Y2=(0,0,1)
X3=(1,0,0)
Y3=(0,1,0)
X1=(0,1,0)
Y1=(0,0,1)
#Random point approach: Select a random base point and draw a loop on a plane through base generated by v1 and v2
base=[1,1,1,1]
v1=rand(-1:1,4)
v2=rand(-1:1,4)
#There should be a 1/n fraction in the text for sage but NOT in the Julia program. Below is the sage text
#u(t)=eval(Meta.parse(utext))
utextp="base+v1*(3+cos(2*pi*t))+v2*(4+sin(2*pi*t))"
utext=replace(utextp,"t" => "t/n")
u(t)=base+v1*(3+cos(2*pi*t))+v2*(4+sin(2*pi*t))
#Expression of f in terms of a point on the Sylvester Pentahedron
f(a,b,c,d,t) = (u(t)[1])*a^3+(u(t)[2])*b^3+(u(t)[3])*c^3+(u(t)[4])*d^3-(a+b+c+d)^3

#In the following code, here is the following approach: we parametrize a plane in cubic space using coordinates x,y with base+x*v1+y*v2. we plot out the discriminant in the plane
#Coefficients a₁,…,a₅ 
@var x y
coeffs(x,y)=[base[1]+x*v1[1]+y*v2[1],base[2]+x*v1[2]+y*v2[2],base[3]+x*v1[3]+y*v2[3],base[4]+x*v1[4]+y*v2[4],1.0]
#Symmetric polynomials in aforementioned coefficients
s1(x,y)=coeffs(x,y)[1]+coeffs(x,y)[2]+coeffs(x,y)[3]+coeffs(x,y)[4]+coeffs(x,y)[5]
s2(x,y)=coeffs(x,y)[2]*coeffs(x,y)[1]+coeffs(x,y)[3]*coeffs(x,y)[1]+coeffs(x,y)[3]*coeffs(x,y)[2]+coeffs(x,y)[4]*coeffs(x,y)[1]+coeffs(x,y)[4]*coeffs(x,y)[2]+coeffs(x,y)[4]*coeffs(x,y)[3]+coeffs(x,y)[5]*coeffs(x,y)[1]+coeffs(x,y)[5]*coeffs(x,y)[2]+coeffs(x,y)[5]*coeffs(x,y)[3]+coeffs(x,y)[5]*coeffs(x,y)[4]
s3(x,y)=coeffs(x,y)[3]*coeffs(x,y)[2]*coeffs(x,y)[1]+coeffs(x,y)[4]*coeffs(x,y)[2]*coeffs(x,y)[1]+coeffs(x,y)[4]*coeffs(x,y)[3]*coeffs(x,y)[1]+coeffs(x,y)[4]*coeffs(x,y)[3]*coeffs(x,y)[2]+coeffs(x,y)[5]*coeffs(x,y)[2]*coeffs(x,y)[1]+coeffs(x,y)[5]*coeffs(x,y)[3]*coeffs(x,y)[1]+coeffs(x,y)[5]*coeffs(x,y)[3]*coeffs(x,y)[2]+coeffs(x,y)[5]*coeffs(x,y)[4]*coeffs(x,y)[1]+coeffs(x,y)[5]*coeffs(x,y)[4]*coeffs(x,y)[2]+coeffs(x,y)[5]*coeffs(x,y)[4]*coeffs(x,y)[3]
s4(x,y)=coeffs(x,y)[4]*coeffs(x,y)[3]*coeffs(x,y)[2]*coeffs(x,y)[1]+coeffs(x,y)[5]*coeffs(x,y)[3]*coeffs(x,y)[2]*coeffs(x,y)[1]+coeffs(x,y)[5]*coeffs(x,y)[4]*coeffs(x,y)[2]*coeffs(x,y)[1]+coeffs(x,y)[5]*coeffs(x,y)[4]*coeffs(x,y)[3]*coeffs(x,y)[1]+coeffs(x,y)[5]*coeffs(x,y)[4]*coeffs(x,y)[3]*coeffs(x,y)[2]
s5(x,y)=coeffs(x,y)[1]*coeffs(x,y)[2]*coeffs(x,y)[3]*coeffs(x,y)[4]*coeffs(x,y)[5]
#The fundamental invariants identified in the paper
A(x,y)=(s4(x,y))^2-4*s3(x,y)*s5(x,y)
B(x,y)=s5(x,y)^3*s1(x,y)
C(x,y)=s5(x,y)^4*s4(x,y)
D(x,y)=s5(x,y)^6*s2(x,y)
E(x,y)=s5(x,y)^8
disc(x,y)=(A(x,y)^2-64*B(x,y))^2-16384*(D(x,y)+(A(x,y)*C(x,y))*1/8)
l1(x,y)=1
l2(x,y)=coeffs(x,y)[1]
l3(x,y)=coeffs(x,y)[2]
l4(x,y)=coeffs(x,y)[3]
l5(x,y)=coeffs(x,y)[4]
disc2(x,y)=3
#How many cubics on the loop to calculate with
n=30
edge=15
#Result vector containing information on lines on each cubic
lineinfo1=[]
#Vector containing how many lines on each cubic
numlines1=[]
printinfo1=[]
lineinfo2=[]
numlines2=[]
printinfo2=[]
numlines3=[]
printinfo3=[]
lineinfo3=[]
#returns true if line centers are close
function compareAdjustedLines(lineq1,lineq2)
    threshold=0.00001
    direction1= lineq1[2]-lineq1[1]>0 ? lineq1[[2,4,6]]-lineq1[[1,3,5]] : lineq1[[1,3,5]]-lineq1[[2,4,6]]
    direction2=lineq2[2]-lineq2[1]>0 ? lineq2[[2,4,6]]-lineq2[[1,3,5]] : lineq2[[1,3,5]]-lineq2[[2,4,6]]
    direction1= direction1/norm(direction1)
    direction2=direction2/norm(direction2)
    direction1= norm(direction1-direction2)<norm(direction1+direction2) ? direction1 : -direction1
    if (lineq1[1]-lineq2[1])^2+(lineq1[3]-lineq2[3])^2+(lineq1[5]-lineq2[5])^2+0.000001*norm(direction1-direction2)^2<threshold
        return true
    else
        return false
    end
end

function unique(lines::Vector{Line})
  uniques = typeof(lines)()
  for line in lines
    isequal = false
    for uniq in uniques
      if line == uniq
        isequal = true
        break
      end
    end
    if !isequal
      push!(uniques, line)
    end
  end
  return uniques
end

#Given 4-tuple lineq, returns 4-tuple x0,x1,y0,y1 such that the line parametrized x0+(x1-x0)*t,y0+(y1-y0)*t for t ∈ (-1,1) yields the entirety of the line inside the box (-5,5)×(-5,5). Otherwise returns 0,0,0,0, the origin
function getIntersection(lineq,X,Y,plane)
    #unordered t-bounds for line inside the box determined by x values of the line. rangex1 yields lower bound for t and rangex2 gives upper
    rangetx1u=(edge-(X[1]*lineq[1]+Y[1]*lineq[3]))/(plane[1]+X[1]*lineq[2]+Y[1]*lineq[4]-X[1]*lineq[1]-Y[1]*lineq[3])
    rangetx2u=(-edge-(X[1]*lineq[1]+Y[1]*lineq[3]))/(plane[1]+X[1]*lineq[2]+Y[1]*lineq[4]-X[1]*lineq[1]-Y[1]*lineq[3])
    rangetx1=min(rangetx1u,rangetx2u)
    rangetx2=max(rangetx1u,rangetx2u)
    #same calculation but for y
    rangety1u=(edge-(X[2]*lineq[1]+Y[2]*lineq[3]))/(plane[2]+X[2]*lineq[2]+Y[2]*lineq[4]-X[2]*lineq[1]-Y[2]*lineq[3])
    rangety2u=(-edge-(X[2]*lineq[1]+Y[2]*lineq[3]))/(plane[2]+X[2]*lineq[2]+Y[2]*lineq[4]-X[2]*lineq[1]-Y[2]*lineq[3])
    rangety1=min(rangety1u,rangety2u)
    rangety2=max(rangety1u,rangety2u)
    #same calculation again but for z
    rangetz1u=(edge-(X[3]*lineq[1]+Y[3]*lineq[3]))/(plane[3]+X[3]*lineq[2]+Y[3]*lineq[4]-X[3]*lineq[1]-Y[3]*lineq[3])
    rangetz2u=(-edge-(X[3]*lineq[1]+Y[3]*lineq[3]))/(plane[3]+X[3]*lineq[2]+Y[3]*lineq[4]-X[3]*lineq[1]-Y[3]*lineq[3])
    rangetz1=min(rangetz1u,rangetz2u)
    rangetz2=max(rangetz1u,rangetz2u)
    #gets the range of t-values for which the line is inside the box
    ranget1=max(rangety1,rangetx1,rangetz1)
    ranget2=min(rangety2,rangetx2,rangetz2)
    #if the line doesn't intersect the box or does at a single point, just return the origin. ranget2 is supposed to be the upper range
    if ranget1 >= ranget2
        println("One of the detected lines does not enter the defined box! Increase the size of the edge variable.")
        return [0.0,0.0,0.0,0.0,0.0,0.0]
    end
    line(T,m)=X[m]*lineq[1]+Y[m]*lineq[3]+(plane[m]+X[m]*lineq[2]+Y[m]*lineq[4]-X[m]*lineq[1]-Y[m]*lineq[3])*T
    centralt=(ranget2+ranget1)/2
    ranget=(ranget2-ranget1)/2
    return [line(centralt,1),line(ranget2,1),line(centralt,2),line(ranget2,2),line(centralt,3),line(ranget2,3)]
end

function identifyLines!(numlines,printinfo,lineinfo,X,Y,plane)
    for t ∈ 0:n
        Gx(s)=X[1]*x1+Y[1]*y1+(plane[1]+X[1]*x2+Y[1]*y2-X[1]*x1-Y[1]*y1)*s
        Gy(s)=X[2]*x1+Y[2]*y1+(plane[2]+X[2]*x2+Y[2]*y2-X[2]*x1-Y[2]*y1)*s
        Gz(s)=X[3]*x1+Y[3]*y1+(plane[3]+X[3]*x2+Y[3]*y2-X[3]*x1-Y[3]*y1)*s
        
        Syss=System([f(Gx(0),Gy(0),Gz(0),1,t/n),f(Gx(1),Gy(1),Gz(1),1,t/n),f(Gx(2),Gy(2),Gz(2),1,t/n),f(Gx(-1),Gy(-1),Gz(-1),1,t/n)])
        solss=HomotopyContinuation.solve(Syss,[0,0,0,0])
        resultlist=results(solss;only_real=true)
        push!(lineinfo,map(L -> getIntersection(L,X,Y,plane),map(x-> map(y -> map(z -> real(z),y), x.solution),resultlist)))
        push!(printinfo,"matrix("*string(lineinfo[t+1])*")")
        push!(numlines,size(resultlist)[1])
    end
end
identifyLines!(numlines1,printinfo1,lineinfo1,X1,Y1,plane1)
identifyLines!(numlines2,printinfo2,lineinfo2,X2,Y2,plane2)
identifyLines!(numlines3,printinfo3,lineinfo3,X3,Y3,plane3)
compiledlineinfo=[]
compiledprintinfo=[]
compilednumlines=[]
for m ∈ 1:n+1
    push!(compiledlineinfo,makeunique([makeunique([lineinfo1[m];lineinfo2[m]]);lineinfo3[m]]))
    push!(compilednumlines,size(compiledlineinfo[m])[1])
    push!(compiledprintinfo,"matrix("*string(compiledlineinfo[m])*")")
end
#Using file L, writes the definition of vector using name varname
function writearray(L,varname,vector,isVector=true)
    write(L,"$(varname)=")
    if isVector
        write(L,"vector(")
    end
    write(L,"[")
    for i ∈ 1:size(vector)[1]
        if i != size(vector)[1]
            write(L,string(vector[i]),",")
        else
            write(L,string(vector[i]))
        end
        
    end
    write(L,"]")
    if isVector
        write(L,")")
    end
    write(L,"\n")
end

run(`./savesystem.sh`)
lci=open("latestcubicinformation","a")
write(lci,"n=$n \n")
write(lci,"edge=$edge\n")
write(lci,"def u(t):\n")
write(lci,"\t return $(utext)\n")
write(lci,"a,b,c=SR.var(\"a,b,c\")\n")
write(lci,"s=SR.var('s')\n")
writearray(lci,"numlines",compilednumlines)
#Tell sage the base vector and the two spanning vectors
writearray(lci,"base",base)
writearray(lci,"v1",v1)
writearray(lci,"v2",v2)
writearray(lci,"V",compiledprintinfo,false)
write(lci,"def frame(t):\n\tlframe=0\n\tfor x in V[t]:\n\t\tlframe+=parametric_plot3d((x[0]+s*(x[1]-x[0]),x[2]+s*(x[3]-x[2]),x[4]+s*(x[5]-x[4])),(s,-1,1),color='yellow',radius=$(0.015*edge))\n\treturn lframe\n")
write(lci,"a=animate([implicit_plot3d((u(t)[0])*a^3+(u(t)[1])*b^3+(u(t)[2])*c^3+(u(t)[3])-(a+b+c+1)^3,(a,-$edge,$edge),(b,-$edge,$edge),(c,-$edge,$edge),plot_points=60)+frame(t) for t in srange(n+1)])\n")
write(lci,"a.interactive(online=True)")
close(lci)
cinfo=open("latesthistory","a")
write(cinfo,"base=",string(base),"\n")
write(cinfo,"v1=",string(v1),"\n")
write(cinfo,"v2=",string(v2),"\n")
write(cinfo,string(disc(x,y)),"\n")
close(cinfo)
run(`./concatenate.sh`)
println(numlines1)
println(numlines2)
println(numlines3)
println(compilednumlines)
println(disc(x,y))
print("fin")
